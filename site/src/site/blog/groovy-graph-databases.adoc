= Using Graph Databases with Groovy
Paul King
:revdate: 2024-08-20T10:18:00+00:00
:keywords: tugraph, tinkerpop, gremlin, neo4j, apache age, graph databases, orientdb, groovy
:draft: true
:description: This post illustrates using graph databases with Groovy.

The Olympics is over for another 4 years. For sports fans, there were many exciting moments.
Let's look at just one event where the Olympic record was broken several times over the
last three years. We'll look at the women's 100m backstroke and model the results as a graph database.

We'll have vertices in our graph database corresponding to the swimmers and the swims.
We'll use the labels `swimmer` and `swim` for these vertices. We'll have relationships
such as `swam` and `supercedes` between vertices. We'll explore modelling and querying the event
information using several graph database technologies.

== Apache TinkerPop

Our first technology to examine is https://tinkerpop.apache.org/[Apache TinkerPopâ„¢].

image:https://tinkerpop.apache.org/img/tinkerpop-splash.png[tinkerpop logo]

TinkerPop is an open source computing framework for graph databases. It provides
a common abstraction layer, and a graph query language, called Gremlin.
This allows you to work with numerous graph database implementations in a consistent way.
TinkerPop also provides its own graph engine implementation, called TinkerGraph, which is what
we'll use initially.

We'll look at the swims in the 2021 and 2024 Olympic finals as well as any preliminary swims
where the Olympic record was broken.

We'll start by creating a new in-memory graph database and
create a helper object for traversing the graph:

[source,groovy]
----
var graph = TinkerGraph.open()
var g = traversal().withEmbedded(graph)
----

Next, let's create the information relevant for the previous Olympic record which was set
at the London 2012 Olympics. Emily Seebohm set that record in Heat 4:

[source,groovy]
----
var es = g.addV('swimmer').property(name: 'Emily Seebohm', country: 'ðŸ‡¦ðŸ‡º').next()
swim1 = g.addV('swim').property(where: 'London 2012', event: 'Heat 4', time: 58.23, result: 'First').next()
es.addEdge('swam', swim1)
----

We can print out some information from our newly created nodes (vertices)
by querying the properties of two nodes respectively:

[source,groovy]
----
var (name, country) = ['name', 'country'].collect { g.V(es).values(it)[0] }
var (where, event, time) = ['where', 'event', 'time'].collect { g.V(swim1).values(it)[0] }
println "$name from $country swam a time of $time in $event at the $where Olympics"
----

Which has this output:

----
Emily Seebohm from ðŸ‡¦ðŸ‡º swam a time of 58.23 in Heat 4 at the London 2012 Olympics
----

So far, we've just been using the Java API from TinkerPop.
It also provides some additional syntactic sugar for Groovy.
We can enable that with:

[source,groovy]
----
SugarLoader.load()
----

Which lets us write the slightly shorter:

[source,groovy]
----
println "$es.name from $es.country swam a time of $swim1.time in $swim1.event at the $swim1.at Olympics"
----

This uses Groovy's normal property access syntax and has the same output when executed.

Let's create some helper methods to simplify creation of the remaining information.

[source,groovy]
----
def insertSwimmer(TraversalSource g, name, country) {
    g.addV('swimmer').property(name: name, country: country).next()
}

def insertSwim(TraversalSource g, where, event, time, result, swimmer) {
    var swim = g.addV('swim').property(where: where, event: event, time: time, result: result).next()
    swimmer.addEdge('swam', swim)
    swim
}
----

Now we can create the remaining swim information:

[source,groovy]
----
var km = insertSwimmer(g, 'Kylie Masse', 'ðŸ‡¨ðŸ‡¦')
var swim2 = insertSwim(g, 'Tokyo 2021', 'Heat 4', 58.17, 'First', km)
swim2.addEdge('supercedes', swim1)
var swim3 = insertSwim(g, 'Tokyo 2021', 'Final', 57.72, 'ðŸ¥ˆ', km)

var rs = insertSwimmer(g, 'Regan Smith', 'ðŸ‡ºðŸ‡¸')
var swim4 = insertSwim(g, 'Tokyo 2021', 'Heat 5', 57.96, 'First', rs)
swim4.addEdge('supercedes', swim2)
var swim5 = insertSwim(g, 'Tokyo 2021', 'Semifinal 1', 57.86, '', rs)
var swim6 = insertSwim(g, 'Tokyo 2021', 'Final', 58.05, 'ðŸ¥‰', rs)
var swim7 = insertSwim(g, 'Paris 2024', 'Final', 57.66, 'ðŸ¥ˆ', rs)
var swim8 = insertSwim(g, 'Paris 2024', 'Relay leg1', 57.28, 'First', rs)

var kmk = insertSwimmer(g, 'Kaylie McKeown', 'ðŸ‡¦ðŸ‡º')
var swim9 = insertSwim(g, 'Tokyo 2021', 'Heat 6', 57.88, 'First', kmk)
swim9.addEdge('supercedes', swim4)
swim5.addEdge('supercedes', swim9)
var swim10 = insertSwim(g, 'Tokyo 2021', 'Final', 57.47, 'ðŸ¥‡', kmk)
swim10.addEdge('supercedes', swim5)
var swim11 = insertSwim(g, 'Paris 2024', 'Final', 57.33, 'ðŸ¥‡', kmk)
swim11.addEdge('supercedes', swim10)
swim8.addEdge('supercedes', swim11)

var kb = insertSwimmer(g, 'Katharine Berkoff', 'ðŸ‡ºðŸ‡¸')
var swim12 = insertSwim(g, 'Paris 2024', 'Final', 57.98, 'ðŸ¥‰', kb)
----

Note that we just entered the swims where medals were won or
where olympic records were broken. We could easily have added
more swimmers, other strokes and distances, and even other sports
if we wanted to.

Let's have a look at what our graph now looks like:

image:https://raw.githubusercontent.com/paulk-asert/groovy-graphdb/main/docs/images/BackstrokeRecords.png[network of swim and swimmer vertices and relationship edges]

We now might want to query the graph in numerous ways.
For instance, what countries had success at the Paris 2024 olympics,
where success is defined for the purposes of this query as
winning a medal or breaking a record. Of course, just having
a swimmer make the olympic team is a great success - but let's
keep our example simple for now.

[source,groovy]
----
var successInParis = g.V().out('swam').has('at', 'Paris 2024').in()
    .values('country').toSet()
assert successInParis == ['ðŸ‡ºðŸ‡¸', 'ðŸ‡¦ðŸ‡º'] as Set
----

By way of explanation, we find all nodes with an outgoing `swam` edge
pointing to a swim that was at the Paris 2024 olympics, i.e.
all the swimmers from Paris 2024. We then find the set of countries
represented.

Similarly, we can find the olympic records set during heat swims:

[source,groovy]
----
var recordSetInHeat = g.V().hasLabel('swim')
    .filter { it.get().property('event').value().startsWith('Heat') }
    .values('at').toSet()
assert recordSetInHeat == ['London 2012', 'Tokyo 2021'] as Set
----

Or, we can find the times of the records set during finals:

[source,groovy]
----
var recordTimesInFinals = g.V().has('event', 'Final').as('ev').out('supercedes')
    .select('ev').values('time').toSet()
assert recordTimesInFinals == [57.47, 57.33] as Set
----

Making use of the Groovy syntactic sugar gives simpler versions:

[source,groovy]
----
var successInParis = g.V.out('swam').has('at', 'Paris 2024').in.country.toSet
assert successInParis == ['ðŸ‡ºðŸ‡¸', 'ðŸ‡¦ðŸ‡º'] as Set

var recordSetInHeat = g.V.hasLabel('swim').filter { it.event.startsWith('Heat') }.at.toSet
assert recordSetInHeat == ['London 2012', 'Tokyo 2021'] as Set

var recordTimesInFinals = g.V.has('event', 'Final').as('ev').out('supercedes').select('ev').time.toSet
assert recordTimesInFinals == [57.47, 57.33] as Set
----

But graph databases really excel when performing queries
involving multiple edge traversals. Here is one looking
at all the olympic records set in 2021 and 2024:

[source,groovy]
----
println "Olympic records after ${g.V(swim1).values('where', 'event').toList().join(' ')}: "
println g.V(swim1).repeat(in('supercedes')).as('sw').emit()
    .values('where').concat(' ')
    .concat(select('sw').values('event')).toList().join('\n')
----

Or after using the Groovy syntactic sugar, the query becomes:

[source,groovy]
----
println g.V(swim1).repeat(in('supercedes')).as('sw').emit
    .at.concat(' ').concat(select('sw').event).toList.join('\n')
----

Both have this output:

[source,groovy]
----
Olympic records after London 2012 Heat 4:
Tokyo 2021 Heat 4
Tokyo 2021 Heat 5
Tokyo 2021 Heat 6
Tokyo 2021 Semifinal 1
Tokyo 2021 Final
Paris 2024 Final
Paris 2024 Relay leg1
----


