= Using Graph Databases with Groovy
Paul King
:revdate: 2024-08-20T10:18:00+00:00
:keywords: tugraph, tinkerpop, gremlin, neo4j, apache age, graph databases, apache hugegraph, orientdb, arcadedb, orientdb, groovy
:draft: true
:description: This post illustrates using graph databases with Groovy.

The Olympics is over for another 4 years. For sports fans, there were many exciting moments.
Let's look at just one event where the Olympic record was broken several times over the
last three years. We'll look at the women's 100m backstroke and model the results as a graph database.

We'll have vertices in our graph database corresponding to the swimmers and the swims.
We'll use the labels `swimmer` and `swim` for these vertices. We'll have relationships
such as `swam` and `supercedes` between vertices. We'll explore modelling and querying the event
information using several graph database technologies.

== Apache TinkerPop

Our first technology to examine is https://tinkerpop.apache.org/[Apache TinkerPopâ„¢].

image:https://tinkerpop.apache.org/img/tinkerpop-splash.png[tinkerpop logo,70%]

TinkerPop is an open source computing framework for graph databases. It provides
a common abstraction layer, and a graph query language, called Gremlin.
This allows you to work with numerous graph database implementations in a consistent way.
TinkerPop also provides its own graph engine implementation, called TinkerGraph, which is what
we'll use initially.

We'll look at the swims for the medalists and record breakers at the Tokyo 2021 and Paris 2024 Olympics
in the women's 100m backstroke. For reference purposes, we'll also include the previous swim that
set an olympic record.

We'll start by creating a new in-memory graph database and
create a helper object for traversing the graph:

[source,groovy]
----
var graph = TinkerGraph.open()
var g = traversal().withEmbedded(graph)
----

Next, let's create the information relevant for the previous Olympic record which was set
at the London 2012 Olympics. Emily Seebohm set that record in Heat 4:

[source,groovy]
----
var es = g.addV('swimmer').property(name: 'Emily Seebohm', country: 'ðŸ‡¦ðŸ‡º').next()
swim1 = g.addV('swim').property(at: 'London 2012', event: 'Heat 4', time: 58.23, result: 'First').next()
es.addEdge('swam', swim1)
----

We can print out some information from our newly created nodes (vertices)
by querying the properties of two nodes respectively:

[source,groovy]
----
var (name, country) = ['name', 'country'].collect { es.property(it).value() }
var (at, event, time) = ['at', 'event', 'time'].collect { swim1.property(it).value() }
println "$name from $country swam a time of $time in $event at the $at Olympics"
----

Which has this output:

----
Emily Seebohm from ðŸ‡¦ðŸ‡º swam a time of 58.23 in Heat 4 at the London 2012 Olympics
----

So far, we've just been using the Java API from TinkerPop.
It also provides some additional syntactic sugar for Groovy.
We can enable the syntactic sugar with:

[source,groovy]
----
SugarLoader.load()
----

Which then lets us write the slightly shorter:

[source,groovy]
----
println "$es.name from $es.country swam a time of $swim1.time in $swim1.event at the $swim1.at Olympics"
----

This uses Groovy's normal property access syntax and has the same output when executed.

Let's create some helper methods to simplify creation of the remaining information.

[source,groovy]
----
def insertSwimmer(TraversalSource g, name, country) {
    g.addV('swimmer').property(name: name, country: country).next()
}

def insertSwim(TraversalSource g, at, event, time, result, swimmer) {
    var swim = g.addV('swim').property(at: at, event: event, time: time, result: result).next()
    swimmer.addEdge('swam', swim)
    swim
}
----

Now we can create the remaining swim information:

[source,groovy]
----
var km = insertSwimmer(g, 'Kylie Masse', 'ðŸ‡¨ðŸ‡¦')
var swim2 = insertSwim(g, 'Tokyo 2021', 'Heat 4', 58.17, 'First', km)
swim2.addEdge('supercedes', swim1)
var swim3 = insertSwim(g, 'Tokyo 2021', 'Final', 57.72, 'ðŸ¥ˆ', km)

var rs = insertSwimmer(g, 'Regan Smith', 'ðŸ‡ºðŸ‡¸')
var swim4 = insertSwim(g, 'Tokyo 2021', 'Heat 5', 57.96, 'First', rs)
swim4.addEdge('supercedes', swim2)
var swim5 = insertSwim(g, 'Tokyo 2021', 'Semifinal 1', 57.86, '', rs)
var swim6 = insertSwim(g, 'Tokyo 2021', 'Final', 58.05, 'ðŸ¥‰', rs)
var swim7 = insertSwim(g, 'Paris 2024', 'Final', 57.66, 'ðŸ¥ˆ', rs)
var swim8 = insertSwim(g, 'Paris 2024', 'Relay leg1', 57.28, 'First', rs)

var kmk = insertSwimmer(g, 'Kaylie McKeown', 'ðŸ‡¦ðŸ‡º')
var swim9 = insertSwim(g, 'Tokyo 2021', 'Heat 6', 57.88, 'First', kmk)
swim9.addEdge('supercedes', swim4)
swim5.addEdge('supercedes', swim9)
var swim10 = insertSwim(g, 'Tokyo 2021', 'Final', 57.47, 'ðŸ¥‡', kmk)
swim10.addEdge('supercedes', swim5)
var swim11 = insertSwim(g, 'Paris 2024', 'Final', 57.33, 'ðŸ¥‡', kmk)
swim11.addEdge('supercedes', swim10)
swim8.addEdge('supercedes', swim11)

var kb = insertSwimmer(g, 'Katharine Berkoff', 'ðŸ‡ºðŸ‡¸')
var swim12 = insertSwim(g, 'Paris 2024', 'Final', 57.98, 'ðŸ¥‰', kb)
----

Note that we just entered the swims where medals were won or
where olympic records were broken. We could easily have added
more swimmers, other strokes and distances, and even other sports
if we wanted to.

Let's have a look at what our graph now looks like:

image:https://raw.githubusercontent.com/paulk-asert/groovy-graphdb/main/docs/images/BackstrokeRecords.png[network of swim and swimmer vertices and relationship edges]

We now might want to query the graph in numerous ways.
For instance, what countries had success at the Paris 2024 olympics,
where success is defined for the purposes of this query as
winning a medal or breaking a record. Of course, just having
a swimmer make the olympic team is a great success - but let's
keep our example simple for now.

[source,groovy]
----
var successInParis = g.V().out('swam').has('at', 'Paris 2024').in()
    .values('country').toSet()
assert successInParis == ['ðŸ‡ºðŸ‡¸', 'ðŸ‡¦ðŸ‡º'] as Set
----

By way of explanation, we find all nodes with an outgoing `swam` edge
pointing to a swim that was at the Paris 2024 olympics, i.e.
all the swimmers from Paris 2024. We then find the set of countries
represented. We are using sets here to remove duplicates, and also
we aren't imposing an ordering on the returned results so we compare
sets on both sides.

Similarly, we can find the olympic records set during heat swims:

[source,groovy]
----
var recordSetInHeat = g.V().hasLabel('swim')
    .filter { it.get().property('event').value().startsWith('Heat') }
    .values('at').toSet()
assert recordSetInHeat == ['London 2012', 'Tokyo 2021'] as Set
----

Or, we can find the times of the records set during finals:

[source,groovy]
----
var recordTimesInFinals = g.V().has('event', 'Final').as('ev').out('supersedes')
    .select('ev').values('time').toSet()
assert recordTimesInFinals == [57.47, 57.33] as Set
----

Making use of the Groovy syntactic sugar gives simpler versions:

[source,groovy]
----
var successInParis = g.V.out('swam').has('at', 'Paris 2024').in.country.toSet
assert successInParis == ['ðŸ‡ºðŸ‡¸', 'ðŸ‡¦ðŸ‡º'] as Set

var recordSetInHeat = g.V.hasLabel('Swim').filter { it.event.startsWith('Heat') }.at.toSet
assert recordSetInHeat == ['London 2012', 'Tokyo 2021'] as Set

var recordTimesInFinals = g.V.has('event', 'Final').as('ev').out('supersedes').select('ev').time.toSet
assert recordTimesInFinals == [57.47, 57.33] as Set
----

But graph databases really excel when performing queries
involving multiple edge traversals. Here is one looking
at all the olympic records set in 2021 and 2024:

[source,groovy]
----
println "Olympic records after ${g.V(swim1).values('at', 'event').toList().join(' ')}: "
println g.V(swim1).repeat(in('supersedes')).as('sw').emit()
    .values('at').concat(' ')
    .concat(select('sw').values('event')).toList().join('\n')
----

Or after using the Groovy syntactic sugar, the query becomes:

[source,groovy]
----
println g.V(swim1).repeat(in('supersedes')).as('sw').emit
    .at.concat(' ').concat(select('sw').event).toList.join('\n')
----

Both have this output:

----
Olympic records after London 2012 Heat 4:
Tokyo 2021 Heat 4
Tokyo 2021 Heat 5
Tokyo 2021 Heat 6
Tokyo 2021 Semifinal 1
Tokyo 2021 Final
Paris 2024 Final
Paris 2024 Relay leg1
----

As a side note, TinkerPop has a `GraphMLWriter` class which can write out our
graph in _GraphML_, which is how the above image was created.

== Neo4j

Our next technology to examine is
https://neo4j.com/product/neo4j-graph-database/[neo4j]. Neo4j is a graph
database storing nodes and edges. Nodes and edges may have a label and properties (or attributes).

image:https://dist.neo4j.com/wp-content/uploads/20230926084108/Logo_FullColor_RGB_TransBG.svg[neo4j logo,50%]

Neo4j models edge relationships using enums. Let's create an enum for our example:

[source,groovy]
----
enum SwimmingRelationships implements RelationshipType {
    swam, supersedes, runnerup
}
----

Let's create our nodes and edges using Neo4j. First the existing Olympic record:

[source,groovy]
----
es = tx.createNode(label('Swimmer'))
es.setProperty('name', 'Emily Seebohm')
es.setProperty('country', 'ðŸ‡¦ðŸ‡º')

swim1 = tx.createNode(label('Swim'))
swim1.setProperty('event', 'Heat 4')
swim1.setProperty('at', 'London 2012')
swim1.setProperty('result', 'First')
swim1.setProperty('time', 58.23d)
es.createRelationshipTo(swim1, swam)

var name = es.getProperty('name')
var country = es.getProperty('country')
var at = swim1.getProperty('at')
var event = swim1.getProperty('event')
var time = swim1.getProperty('time')
println "$name from $country swam a time of $time in $event at the $at Olympics"
----

While there is nothing wrong with this code, Groovy has many features for making code more succinct.
Let's use some dynamic metaprogramming to achieve just that.

[source,groovy]
----
Node.metaClass {
    propertyMissing { String name, val -> delegate.setProperty(name, val) }
    propertyMissing { String name -> delegate.getProperty(name) }
    methodMissing { String name, args ->
        delegate.createRelationshipTo(args[0], SwimmingRelationships."$name")
    }
}
----

Now we use normal Groovy property access for setting the node properties. It looks much cleaner.
We define an edge relationship simply by calling a method having the relationship name.

[source,groovy]
----
km = tx.createNode(label('swimmer'))
km.name = 'Kylie Masse'
km.country = 'ðŸ‡¨ðŸ‡¦'

swim2 = tx.createNode(label('swim'))
swim2.time = 58.17d
swim2.result = 'First'
swim2.event = 'Heat 4'
swim2.at = 'Tokyo 2021'
km.swam(swim2)
swim2.supercedes(swim1)

swim3 = tx.createNode(label('swim'))
swim3.time = 57.72d
swim3.result = 'ðŸ¥ˆ'
swim3.event = 'Final'
swim3.at = 'Tokyo 2021'
km.swam(swim3)
----

The code is certainly a lot cleaner, and it was quite a minimal amount of work to define the necessary
metaprogramming. With a little bit more work, we could use static metaprogramming techniques.
This would give us better IDE completion.

Another interesting topic which we won't elaborate here is stronger type checking for graphs.
For graph libraries which support schemas, the types for node and edge properties can be defined,
as can the allowable nodes applicable to any edge relationship. For such systems, if you try to
define a poorly-typed property, or incorrectly use a relationship, you will receive a runtime error.
Groovy lets us take things further, if we want, and if we are willing to do a little more work.
For example, if the schema is available at compile time, we could write a type checking extension
which would fail compilation if any invalid edge or vertex definitions were detected.

For now though, let's continue with defining the rest of our graph.
We can redefine our `insertSwimmer` and `insertSwim` methods using Neo4j implementation
calls, and then our earlier code could be used to create our graph. Now let's
investigate what the queries look like.

First, the successful countries in Paris 2024:

[source,groovy]
----
var swimmers = [es, km, rs, kmk, kb]
var successInParis = swimmers.findAll { swimmer ->
    swimmer.getRelationships(swam).any { run ->
        run.getOtherNode(swimmer).at == 'Paris 2024'
    }
}
assert successInParis*.country.unique() == ['ðŸ‡ºðŸ‡¸', 'ðŸ‡¦ðŸ‡º']
----

Then, at which olympics were records broken in heats:

[source,groovy]
----
var swims = [swim1, swim2, swim3, swim4, swim5, swim6, swim7, swim8, swim9, swim10, swim11, swim12]
var recordSetInHeat = swims.findAll { swim ->
    swim.event.startsWith('Heat')
}*.at
assert recordSetInHeat.unique() == ['London 2012', 'Tokyo 2021']
----

Now, what were the times for records broken in finals:

[source,groovy]
----
var recordTimesInFinals = swims.findAll { swim ->
    swim.event == 'Final' && swim.hasRelationship(supercedes)
}*.time
assert recordTimesInFinals == [57.47d, 57.33d]
----

To see traversal in action, Neo4j has a special API for doing such queries:

[source,groovy]
----
var info = { s -> "$s.at $s.event" }
println "Olympic records following ${info(swim1)}:"

for (Path p in tx.traversalDescription()
    .breadthFirst()
    .relationships(supersedes)
    .evaluator(Evaluators.fromDepth(1))
    .uniqueness(Uniqueness.NONE)
    .traverse(swim1)) {
    println p.endNode().with(info)
}
----

Earlier versions of Neo4j also supported Gremlin, so we could have written our queries in
the same was as we did for TinkerPop. That technology is deprecated for Neo4j, and instead
they now offer a Cypher query language. We can use that language for all of our previous queries
as shown here:

[source,groovy]
----
assert tx.execute('''
MATCH (s:Swim WHERE s.event STARTS WITH 'Heat')
WITH s.at as at
WITH DISTINCT at
RETURN at
''')*.at == ['London 2012', 'Tokyo 2021']

assert tx.execute('''
MATCH (s1:Swim {event: 'Final'})-[:supersedes]->(s2:Swim)
RETURN s1.time AS time
''')*.time == [57.47d, 57.33d]

tx.execute('''
MATCH (s1:Swim)-[:supersedes]->{1,}(s2:Swim { at: $at })
RETURN s1
''', [at: swim1.at])*.s1.each { s ->
    println "$s.at $s.event"
}
----

=== An aside on graph design

Deciding which information should be stored as node properties and which as relationships
still requires developer judgement. For example, we could have added a Boolean `olympicRecord`
property to our `Swim` nodes. Certain queries might now become simpler, or at least more familiar
to traditional RDBMS SQL developers, but other queries might become much harder to write
and potentially much less efficient.
This is the kind of thing which needs to be thought through and sometimes experimented with.

Suppose, in the case where a record is broken, we wanted to see which other swimmers
(in our case medallists in the final) also broke the previous record.
We could write a query to find this as follows:

[source,groovy]
----
assert tx.execute('''
MATCH (sr1:swimmer)-[:swam]->(sm1:swim {event: 'Final'}), (sm2:swim {event: 'Final'})-[:supercedes]->(sm3:swim)
WHERE sm1.at = sm2.at AND sm1 <> sm2 AND sm1.time < sm3.time
RETURN sr1.name as name
''')*.name == ['Kylie Masse']
----

It's not too bad, but if we had a much larger graph of data, it could be quite slow.
We could instead opt to use an additional relationship, called `runnerup` in our graph.

[source,groovy]
----
swim6.runnerup(swim3)
swim3.runnerup(swim10)
swim12.runnerup(swim7)
swim7.runnerup(swim11)
----

The visualization is something like this:

image:img/BackstrokeRecordsRunnerup.png[Additional runnerup relationship,60%]

It essentially makes it easier to find the other medalists if we know any one of them.

The resulting query becomes this:

[source,groovy]
----
assert tx.execute('''
MATCH (sr1:swimmer)-[:swam]->(sm1:swim {event: 'Final'})-[:runnerup]->{1,2}(sm2:swim {event: 'Final'})-[:supercedes]->(sm3:swim)
WHERE sm1.time < sm3.time
RETURN sr1.name as name
''')*.name == ['Kylie Masse']
----

The _MATCH_ clause is similar in complexity, the _WHERE_ clause is much simpler.
The query is probably faster too, but it is a tradeoff that should be weighed up.

== Apache AGE

The next technology is the https://age.apache.org/[Apache AGEâ„¢] graph database.
Apache AGE leverages https://www.postgresql.org[PostgreSQL] for storage.

image:https://age.apache.org/age-manual/master/_static/logo.png[Apache AGE logo, 50%]
image:https://age.apache.org/img/logo-large-postgresql.jpg[PostgreSQL logo]

We installed Apache AGE via a Docker Image as outlined in the Apache AGE
https://age.apache.org/age-manual/master/intro/setup.html#installing-via-docker-image[manual].

Since Apache AGE offers a SQL-inspired graph database experience, we use Groovy's
SQL facilities to interact with the database:

[source,groovy]
----
Sql.withInstance(DB_URL, USER, PASS, 'org.postgresql.jdbc.PgConnection') { sql ->
    // enable Apache AGE extension, then use Sql connection ...
}
----

For creating our nodes and subsequent querying, we use SQL statements
with embedded _cypher_ clauses. Here is the statement for creating
out nodes and edges:

[source,groovy]
----
sql.execute'''
    SELECT * FROM cypher('swimming_graph', $$ CREATE
    (es:swimmer {name: 'Emily Seebohm', country: 'ðŸ‡¦ðŸ‡º'}),
    (swim1:swim {event: 'Heat 4', result: 'First', time: 58.23, at: 'London 2012'}),
    (es)-[:swam]->(swim1),

    (km:swimmer {name: 'Kylie Masse', country: 'ðŸ‡¨ðŸ‡¦'}),
    (swim2:swim {event: 'Heat 4', result: 'First', time: 58.17, at: 'Tokyo 2021'}),
    (km)-[:swam]->(swim2),
    (swim2)-[:supercedes]->(swim1),
    (swim3:swim {event: 'Final', result: 'ðŸ¥ˆ', time: 57.72, at: 'Tokyo 2021'}),
    (km)-[:swam]->(swim3),

    (rs:swimmer {name: 'Regan Smith', country: 'ðŸ‡ºðŸ‡¸'}),
    (swim4:swim {event: 'Heat 5', result: 'First', time: 57.96, at: 'Tokyo 2021'}),
    (rs)-[:swam]->(swim4),
    (swim4)-[:supercedes]->(swim2),
    (swim5:swim {event: 'Semifinal 1', result: 'First', time: 57.86, at: 'Tokyo 2021'}),
    (rs)-[:swam]->(swim5),
    (swim6:swim {event: 'Final', result: 'ðŸ¥‰', time: 58.05, at: 'Tokyo 2021'}),
    (rs)-[:swam]->(swim6),
    (swim7:swim {event: 'Final', result: 'ðŸ¥ˆ', time: 57.66, at: 'Paris 2024'}),
    (rs)-[:swam]->(swim7),
    (swim8:swim {event: 'Relay leg1', result: 'First', time: 57.28, at: 'Paris 2024'}),
    (rs)-[:swam]->(swim8),

    (kmk:swimmer {name: 'Kaylie McKeown', country: 'ðŸ‡¦ðŸ‡º'}),
    (swim9:swim {event: 'Heat 6', result: 'First', time: 57.88, at: 'Tokyo 2021'}),
    (kmk)-[:swam]->(swim9),
    (swim9)-[:supercedes]->(swim4),
    (swim5)-[:supercedes]->(swim9),
    (swim10:swim {event: 'Final', result: 'ðŸ¥‡', time: 57.47, at: 'Tokyo 2021'}),
    (kmk)-[:swam]->(swim10),
    (swim10)-[:supercedes]->(swim5),
    (swim11:swim {event: 'Final', result: 'ðŸ¥‡', time: 57.33, at: 'Paris 2024'}),
    (kmk)-[:swam]->(swim11),
    (swim11)-[:supercedes]->(swim10),
    (swim8)-[:supercedes]->(swim11),

    (kb:swimmer {name: 'Katharine Berkoff', country: 'ðŸ‡ºðŸ‡¸'}),
    (swim12:swim {event: 'Final', result: 'ðŸ¥‰', time: 57.98, at: 'Paris 2024'}),
    (kb)-[:swam]->(swim12)
    $$) AS (a agtype)
'''
----

To find which olympics where records were set in heats, we
can use the following _cypher_ query:

[source,groovy]
----
assert sql.rows('''
    SELECT * from cypher('swimming_graph', $$
    MATCH (s:swim)
    WHERE left(s.event, 4) = 'Heat'
    RETURN s
    $$) AS (a agtype)
''').a*.map*.get('properties')*.at.toUnique() == ['London 2012', 'Tokyo 2021']
----

The results come back in a special JSON-like data type called `agtype`.
From that, we can query the properties and return the `at` property.
We select the unique ones to remove duplicates.

Similarly, we can find the times of olympic records set in finals
as follows:

[source,groovy]
----
assert sql.rows('''
    SELECT * from cypher('swimming_graph', $$
    MATCH (s1:swim {event: 'Final'})-[:supercedes]->(s2:swim)
    RETURN s1
    $$) AS (a agtype)
''').a*.map*.get('properties')*.time == [57.47, 57.33]
----

To print all the olympic records set across Tokyo 2021 and Paris 2024,
we can use `eachRow` and the following query:

[source,groovy]
----
sql.eachRow('''
    SELECT * from cypher('swimming_graph', $$
    MATCH (s1:swim)-[:supercedes]->(swim1)
    RETURN s1
    $$) AS (a agtype)
''') {
    println it.a*.map*.get('properties')[0].with{ "$it.at $it.event" }
}
----

The output looks like this:

----
Tokyo 2021 Heat 4
Tokyo 2021 Heat 5
Tokyo 2021 Heat 6
Tokyo 2021 Final
Tokyo 2021 Semifinal 1
Paris 2024 Final
Paris 2024 Relay leg1
----

The Apache AGE project also maintains a viewer tool offering a web-based
user interface for visualization of graph data stored in our database.
Instructions for installation are available on the
https://github.com/apache/age-viewer[GitHub site].
The tool allows visualization of the results from any query.
For our database, a query returning all nodes and edges creates
a visualization like below (we chose to manually re-arrange the nodes):

image:img/age-viewer.png[]

== OrientDB

[source,groovy]
----
----

== ArcadeDB

image:img/ArcadeStudio.png[ArcadeStudio]

[source,groovy]
----
----

== TuGraph

[source,groovy]
----
----

== HugeGraph

[source,groovy]
----
----
