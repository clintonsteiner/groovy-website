= Using Graph Databases with Groovy
Paul King
:revdate: 2024-08-20T10:18:00+00:00
:keywords: tugraph, tinkerpop, gremlin, neo4j, apache age, graph databases, orientdb, groovy
:draft: true
:description: This post illustrates using graph databases with Groovy.

The Olympics is over for another 4 years. For sports fans, there were many exciting moments.
Let's look at just one event where the Olympic record was broken several times over the
last three years. We'll look at the women's 100m backstroke and model the results as a graph database.

We'll have vertices in our graph database corresponding to the swimmers and the swims.
We'll use the labels `swimmer` and `swim` for these vertices. We'll have relationships
such as `swam` and `supercedes` between vertices. We'll explore modelling and querying the event
information using several graph database technologies.

== Apache TinkerPop

Our first technology to examine is https://tinkerpop.apache.org/[Apache TinkerPopâ„¢].

image:https://tinkerpop.apache.org/img/tinkerpop-splash.png[tinkerpop logo,70%]

TinkerPop is an open source computing framework for graph databases. It provides
a common abstraction layer, and a graph query language, called Gremlin.
This allows you to work with numerous graph database implementations in a consistent way.
TinkerPop also provides its own graph engine implementation, called TinkerGraph, which is what
we'll use initially.

We'll look at the swims in the 2021 and 2024 Olympic finals as well as any preliminary swims
where the Olympic record was broken.

We'll start by creating a new in-memory graph database and
create a helper object for traversing the graph:

[source,groovy]
----
var graph = TinkerGraph.open()
var g = traversal().withEmbedded(graph)
----

Next, let's create the information relevant for the previous Olympic record which was set
at the London 2012 Olympics. Emily Seebohm set that record in Heat 4:

[source,groovy]
----
var es = g.addV('swimmer').property(name: 'Emily Seebohm', country: 'ðŸ‡¦ðŸ‡º').next()
swim1 = g.addV('swim').property(at: 'London 2012', event: 'Heat 4', time: 58.23, result: 'First').next()
es.addEdge('swam', swim1)
----

We can print out some information from our newly created nodes (vertices)
by querying the properties of two nodes respectively:

[source,groovy]
----
var (name, country) = ['name', 'country'].collect { g.V(es).values(it)[0] }
var (at, event, time) = ['at', 'event', 'time'].collect { g.V(swim1).values(it)[0] }
println "$name from $country swam a time of $time in $event at the $at Olympics"
----

Which has this output:

----
Emily Seebohm from ðŸ‡¦ðŸ‡º swam a time of 58.23 in Heat 4 at the London 2012 Olympics
----

So far, we've just been using the Java API from TinkerPop.
It also provides some additional syntactic sugar for Groovy.
We can enable that with:

[source,groovy]
----
SugarLoader.load()
----

Which lets us write the slightly shorter:

[source,groovy]
----
println "$es.name from $es.country swam a time of $swim1.time in $swim1.event at the $swim1.at Olympics"
----

This uses Groovy's normal property access syntax and has the same output when executed.

Let's create some helper methods to simplify creation of the remaining information.

[source,groovy]
----
def insertSwimmer(TraversalSource g, name, country) {
    g.addV('swimmer').property(name: name, country: country).next()
}

def insertSwim(TraversalSource g, at, event, time, result, swimmer) {
    var swim = g.addV('swim').property(at: at, event: event, time: time, result: result).next()
    swimmer.addEdge('swam', swim)
    swim
}
----

Now we can create the remaining swim information:

[source,groovy]
----
var km = insertSwimmer(g, 'Kylie Masse', 'ðŸ‡¨ðŸ‡¦')
var swim2 = insertSwim(g, 'Tokyo 2021', 'Heat 4', 58.17, 'First', km)
swim2.addEdge('supercedes', swim1)
var swim3 = insertSwim(g, 'Tokyo 2021', 'Final', 57.72, 'ðŸ¥ˆ', km)

var rs = insertSwimmer(g, 'Regan Smith', 'ðŸ‡ºðŸ‡¸')
var swim4 = insertSwim(g, 'Tokyo 2021', 'Heat 5', 57.96, 'First', rs)
swim4.addEdge('supercedes', swim2)
var swim5 = insertSwim(g, 'Tokyo 2021', 'Semifinal 1', 57.86, '', rs)
var swim6 = insertSwim(g, 'Tokyo 2021', 'Final', 58.05, 'ðŸ¥‰', rs)
var swim7 = insertSwim(g, 'Paris 2024', 'Final', 57.66, 'ðŸ¥ˆ', rs)
var swim8 = insertSwim(g, 'Paris 2024', 'Relay leg1', 57.28, 'First', rs)

var kmk = insertSwimmer(g, 'Kaylie McKeown', 'ðŸ‡¦ðŸ‡º')
var swim9 = insertSwim(g, 'Tokyo 2021', 'Heat 6', 57.88, 'First', kmk)
swim9.addEdge('supercedes', swim4)
swim5.addEdge('supercedes', swim9)
var swim10 = insertSwim(g, 'Tokyo 2021', 'Final', 57.47, 'ðŸ¥‡', kmk)
swim10.addEdge('supercedes', swim5)
var swim11 = insertSwim(g, 'Paris 2024', 'Final', 57.33, 'ðŸ¥‡', kmk)
swim11.addEdge('supercedes', swim10)
swim8.addEdge('supercedes', swim11)

var kb = insertSwimmer(g, 'Katharine Berkoff', 'ðŸ‡ºðŸ‡¸')
var swim12 = insertSwim(g, 'Paris 2024', 'Final', 57.98, 'ðŸ¥‰', kb)
----

Note that we just entered the swims where medals were won or
where olympic records were broken. We could easily have added
more swimmers, other strokes and distances, and even other sports
if we wanted to.

Let's have a look at what our graph now looks like:

image:https://raw.githubusercontent.com/paulk-asert/groovy-graphdb/main/docs/images/BackstrokeRecords.png[network of swim and swimmer vertices and relationship edges]

We now might want to query the graph in numerous ways.
For instance, what countries had success at the Paris 2024 olympics,
where success is defined for the purposes of this query as
winning a medal or breaking a record. Of course, just having
a swimmer make the olympic team is a great success - but let's
keep our example simple for now.

[source,groovy]
----
var successInParis = g.V().out('swam').has('at', 'Paris 2024').in()
    .values('country').toSet()
assert successInParis == ['ðŸ‡ºðŸ‡¸', 'ðŸ‡¦ðŸ‡º'] as Set
----

By way of explanation, we find all nodes with an outgoing `swam` edge
pointing to a swim that was at the Paris 2024 olympics, i.e.
all the swimmers from Paris 2024. We then find the set of countries
represented.

Similarly, we can find the olympic records set during heat swims:

[source,groovy]
----
var recordSetInHeat = g.V().hasLabel('swim')
    .filter { it.get().property('event').value().startsWith('Heat') }
    .values('at').toSet()
assert recordSetInHeat == ['London 2012', 'Tokyo 2021'] as Set
----

Or, we can find the times of the records set during finals:

[source,groovy]
----
var recordTimesInFinals = g.V().has('event', 'Final').as('ev').out('supercedes')
    .select('ev').values('time').toSet()
assert recordTimesInFinals == [57.47, 57.33] as Set
----

Making use of the Groovy syntactic sugar gives simpler versions:

[source,groovy]
----
var successInParis = g.V.out('swam').has('at', 'Paris 2024').in.country.toSet
assert successInParis == ['ðŸ‡ºðŸ‡¸', 'ðŸ‡¦ðŸ‡º'] as Set

var recordSetInHeat = g.V.hasLabel('swim').filter { it.event.startsWith('Heat') }.at.toSet
assert recordSetInHeat == ['London 2012', 'Tokyo 2021'] as Set

var recordTimesInFinals = g.V.has('event', 'Final').as('ev').out('supercedes').select('ev').time.toSet
assert recordTimesInFinals == [57.47, 57.33] as Set
----

But graph databases really excel when performing queries
involving multiple edge traversals. Here is one looking
at all the olympic records set in 2021 and 2024:

[source,groovy]
----
println "Olympic records after ${g.V(swim1).values('at', 'event').toList().join(' ')}: "
println g.V(swim1).repeat(in('supercedes')).as('sw').emit()
    .values('at').concat(' ')
    .concat(select('sw').values('event')).toList().join('\n')
----

Or after using the Groovy syntactic sugar, the query becomes:

[source,groovy]
----
println g.V(swim1).repeat(in('supercedes')).as('sw').emit
    .at.concat(' ').concat(select('sw').event).toList.join('\n')
----

Both have this output:

----
Olympic records after London 2012 Heat 4:
Tokyo 2021 Heat 4
Tokyo 2021 Heat 5
Tokyo 2021 Heat 6
Tokyo 2021 Semifinal 1
Tokyo 2021 Final
Paris 2024 Final
Paris 2024 Relay leg1
----

== Neo4j

Our next technology to examine is
https://neo4j.com/product/neo4j-graph-database/[neo4j]. Neo4j is a graph
database storing nodes and edges. Nodes and edges may have a label and properties (or attributes).

image:https://dist.neo4j.com/wp-content/uploads/20230926084108/Logo_FullColor_RGB_TransBG.svg[neo4j logo,50%]

[source,groovy]
----
es = tx.createNode(label('swimmer'))
es.setProperty('name', 'Emily Seebohm')
es.setProperty('country', 'ðŸ‡¦ðŸ‡º')

swim1 = tx.createNode(label('swim'))
swim1.setProperty('event', 'Heat 4')
swim1.setProperty('at', 'London 2012')
swim1.setProperty('result', 'First')
swim1.setProperty('time', 58.23d)
es.createRelationshipTo(swim1, swam)

var name = es.getProperty('name')
var country = es.getProperty('country')
var at = swim1.getProperty('at')
var event = swim1.getProperty('event')
var time = swim1.getProperty('time')
println "$name from $country swam a time of $time in $event at the $at Olympics"
----

[source,groovy]
----
Node.metaClass {
    propertyMissing { String name, val -> delegate.setProperty(name, val) }
    propertyMissing { String name -> delegate.getProperty(name) }
    methodMissing { String name, args ->
        delegate.createRelationshipTo(args[0], SwimmingRelationships."$name")
    }
}
----

[source,groovy]
----
km = tx.createNode(label('swimmer'))
km.name = 'Kylie Masse'
km.country = 'ðŸ‡¨ðŸ‡¦'

swim2 = tx.createNode(label('swim'))
swim2.time = 58.17d
swim2.result = 'First'
swim2.event = 'Heat 4'
swim2.at = 'Tokyo 2021'
km.swam(swim2)
swim2.supercedes(swim1)

swim3 = tx.createNode(label('swim'))
swim3.time = 57.72d
swim3.result = 'ðŸ¥ˆ'
swim3.event = 'Final'
swim3.at = 'Tokyo 2021'
km.swam(swim3)
----

[source,groovy]
----
static insertSwimmer(Transaction tx, name, country) {
    var sr = tx.createNode(label('swimmer'))
    sr.setProperty('name', name)
    sr.setProperty('country', country)
    sr
}

static insertSwim(Transaction tx, at, event, time, result, swimmer) {
    var sm = tx.createNode(label('swim'))
    sm.setProperty('result', result)
    sm.setProperty('event', event)
    sm.setProperty('at', at)
    sm.setProperty('time', time)
    swimmer.createRelationshipTo(sm, swam)
    sm
}
----

[source,groovy]
----
var swimmers = [es, km, rs, kmk, kb]
var successInParis = swimmers.findAll { swimmer ->
    swimmer.getRelationships(swam).any { run ->
        run.getOtherNode(swimmer).at == 'Paris 2024'
    }
}
assert successInParis*.country.unique() == ['ðŸ‡ºðŸ‡¸', 'ðŸ‡¦ðŸ‡º']

var swims = [swim1, swim2, swim3, swim4, swim5, swim6, swim7, swim8, swim9, swim10, swim11, swim12]
var recordSetInHeat = swims.findAll { swim ->
    swim.event.startsWith('Heat')
}*.at
assert recordSetInHeat.unique() == ['London 2012', 'Tokyo 2021']

var recordTimesInFinals = swims.findAll { swim ->
    swim.event == 'Final' && swim.hasRelationship(supercedes)
}*.time
assert recordTimesInFinals == [57.47d, 57.33d]

var info = { s -> "$s.at $s.event" }
println "Olympic records following ${info(swim1)}:"

for (Path p in tx.traversalDescription()
    .breadthFirst()
    .relationships(supercedes)
    .evaluator(Evaluators.fromDepth(1))
    .uniqueness(Uniqueness.NONE)
    .traverse(swim1)) {
    println p.endNode().with(info)
}
----

[source,groovy]
----
assert tx.execute('''
MATCH (s:swim WHERE s.event STARTS WITH 'Heat')
WITH s.at as at
WITH DISTINCT at
RETURN at
''')*.at == ['London 2012', 'Tokyo 2021']

assert tx.execute('''
MATCH (s1:swim {event: 'Final'})-[:supercedes]->(s2:swim)
RETURN s1.time AS time
''')*.time == [57.47d, 57.33d]

tx.execute('''
MATCH (s1:swim)-[:supercedes]->{1,}(s2:swim { at: $at })
RETURN s1
''', [at: swim1.at])*.s1.each { s ->
    println "$s.at $s.event"
}

assert tx.execute('''
MATCH (sr1:swimmer)-[:swam]->(sm1:swim {event: 'Final'}), (sm2:swim {event: 'Final'})-[:supercedes]->(sm3:swim)
WHERE sm1.at = sm2.at AND sm1 <> sm2 AND sm1.time < sm3.time
RETURN sr1.name as name
''')*.name == ['Kylie Masse']
----

[source,groovy]
----
swim6.runnerup(swim3)
swim3.runnerup(swim10)
swim12.runnerup(swim7)
swim7.runnerup(swim11)

assert tx.execute('''
MATCH (sr1:swimmer)-[:swam]->(sm1:swim {event: 'Final'})-[:runnerup]->{1,2}(sm2:swim {event: 'Final'})-[:supercedes]->(sm3:swim)
WHERE sm1.time < sm3.time
RETURN sr1.name as name
''')*.name == ['Kylie Masse']
----

== Apache AGE

The next technology is the https://age.apache.org/[Apache AGEâ„¢] graph database.
Apache AGE leverages https://www.postgresql.org[PostgreSQL] for storage.

image:https://age.apache.org/age-manual/master/_static/logo.png[Apache AGE logo, 50%]
image:https://age.apache.org/img/logo-large-postgresql.jpg[PostgreSQL logo]

We installed Apache AGE via a Docker Image as outlined in the Apache AGE
https://age.apache.org/age-manual/master/intro/setup.html#installing-via-docker-image[manual].

Since Apache AGE offers a SQL-inspired graph database experience, we use Groovy's
SQL facilities to interact with the database:

[source,groovy]
----
Sql.withInstance(DB_URL, USER, PASS, 'org.postgresql.jdbc.PgConnection') { sql ->
    // enable Apache AGE extension, then use Sql connection ...
}
----

For creating our nodes and subsequent querying, we use SQL statements
with embedded _cypher_ clauses. Here is the statement for creating
out nodes and edges:

[source,groovy]
----
sql.execute'''
    SELECT * FROM cypher('swimming_graph', $$ CREATE
    (es:swimmer {name: 'Emily Seebohm', country: 'ðŸ‡¦ðŸ‡º'}),
    (swim1:swim {event: 'Heat 4', result: 'First', time: 58.23, at: 'London 2012'}),
    (es)-[:swam]->(swim1),

    (km:swimmer {name: 'Kylie Masse', country: 'ðŸ‡¨ðŸ‡¦'}),
    (swim2:swim {event: 'Heat 4', result: 'First', time: 58.17, at: 'Tokyo 2021'}),
    (km)-[:swam]->(swim2),
    (swim2)-[:supercedes]->(swim1),
    (swim3:swim {event: 'Final', result: 'ðŸ¥ˆ', time: 57.72, at: 'Tokyo 2021'}),
    (km)-[:swam]->(swim3),

    (rs:swimmer {name: 'Regan Smith', country: 'ðŸ‡ºðŸ‡¸'}),
    (swim4:swim {event: 'Heat 5', result: 'First', time: 57.96, at: 'Tokyo 2021'}),
    (rs)-[:swam]->(swim4),
    (swim4)-[:supercedes]->(swim2),
    (swim5:swim {event: 'Semifinal 1', result: 'First', time: 57.86, at: 'Tokyo 2021'}),
    (rs)-[:swam]->(swim5),
    (swim6:swim {event: 'Final', result: 'ðŸ¥‰', time: 58.05, at: 'Tokyo 2021'}),
    (rs)-[:swam]->(swim6),
    (swim7:swim {event: 'Final', result: 'ðŸ¥ˆ', time: 57.66, at: 'Paris 2024'}),
    (rs)-[:swam]->(swim7),
    (swim8:swim {event: 'Relay leg1', result: 'First', time: 57.28, at: 'Paris 2024'}),
    (rs)-[:swam]->(swim8),

    (kmk:swimmer {name: 'Kaylie McKeown', country: 'ðŸ‡¦ðŸ‡º'}),
    (swim9:swim {event: 'Heat 6', result: 'First', time: 57.88, at: 'Tokyo 2021'}),
    (kmk)-[:swam]->(swim9),
    (swim9)-[:supercedes]->(swim4),
    (swim5)-[:supercedes]->(swim9),
    (swim10:swim {event: 'Final', result: 'ðŸ¥‡', time: 57.47, at: 'Tokyo 2021'}),
    (kmk)-[:swam]->(swim10),
    (swim10)-[:supercedes]->(swim5),
    (swim11:swim {event: 'Final', result: 'ðŸ¥‡', time: 57.33, at: 'Paris 2024'}),
    (kmk)-[:swam]->(swim11),
    (swim11)-[:supercedes]->(swim10),
    (swim8)-[:supercedes]->(swim11),

    (kb:swimmer {name: 'Katharine Berkoff', country: 'ðŸ‡ºðŸ‡¸'}),
    (swim12:swim {event: 'Final', result: 'ðŸ¥‰', time: 57.98, at: 'Paris 2024'}),
    (kb)-[:swam]->(swim12)
    $$) AS (a agtype)
'''
----

To find which olympics where records were set in heats, we
can use the following _cypher_ query:

[source,groovy]
----
assert sql.rows('''
    SELECT * from cypher('swimming_graph', $$
    MATCH (s:swim)
    WHERE left(s.event, 4) = 'Heat'
    RETURN s
    $$) AS (a agtype)
''').a*.map*.get('properties')*.at.toUnique() == ['London 2012', 'Tokyo 2021']
----

The results come back in a special JSON-like data type called `agtype`.
From that, we can query the properties and return the `at` property.
We select the unique ones to remove duplicates.

Similarly, we can find the times of olympic records set in finals
as follows:

[source,groovy]
----
assert sql.rows('''
    SELECT * from cypher('swimming_graph', $$
    MATCH (s1:swim {event: 'Final'})-[:supercedes]->(s2:swim)
    RETURN s1
    $$) AS (a agtype)
''').a*.map*.get('properties')*.time == [57.47, 57.33]
----

To print all the olympic records set across Tokyo 2021 and Paris 2024,
we can use `eachRow` and the following query:

[source,groovy]
----
sql.eachRow('''
    SELECT * from cypher('swimming_graph', $$
    MATCH (s1:swim)-[:supercedes]->(swim1)
    RETURN s1
    $$) AS (a agtype)
''') {
    println it.a*.map*.get('properties')[0].with{ "$it.at $it.event" }
}
----

The output looks like this:

----
Tokyo 2021 Heat 4
Tokyo 2021 Heat 5
Tokyo 2021 Heat 6
Tokyo 2021 Final
Tokyo 2021 Semifinal 1
Paris 2024 Final
Paris 2024 Relay leg1
----

The Apache AGE project also maintains a viewer tool offering a web-based
user interface for visualization of graph data stored in our database.
Instructions for installation are available on the
https://github.com/apache/age-viewer[GitHub site].
The tool allows visualization of the results from any query.
For our database, a query returning all nodes and edges looks like this:

image:img/age-viewer.png[]

== OrientDB

[source,groovy]
----
----

== TuGraph

[source,groovy]
----
----
